# JavaModel
#### 1. SimpleFactory简单工厂模式
#### 工厂类拥有一个工厂方法，接受了一个参数，通过不同的参数实例化不同的产品类。
+ 优点：
    + 简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类。
+ 缺点：
    + 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大。
    + 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。
#### 2. FactoryMethod工厂方法模式
#### 工厂方法是针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例。
+ 优点：
    + 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产（对应简单工厂的缺点1）
    + 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开放-封闭原则。
+ 缺点：
    + 相比简单工厂，实现略复杂。
    + 对于某些可以形成产品族的情况处理比较复杂。
#### 3. AbstractFactory抽象工厂模式
#### 抽象工厂是应对产品族概念的
+ 优点：
    + 针对产品族。
+ 缺点：
    + 针对产品族。
+ 特点：
    + 只有对应产品族的情况下，才需要使用抽象工厂模式。
#### 4. Singleton单例模式
#### 指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
+ 特点：
    + 单例类只有一个实例对象。
    + 该单例对象必须由单例类自行创建。
    + 单例类对外提供一个访问该单例的全局访问点。
#### 5. Prototype原型模式
#### 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
#### 6. Builder建造者模式
#### 指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
+ 优点：
    + 各个具体的建造者相互独立，有利于系统的扩展。
    + 客户端不必知道产品内部组成的细节，便于控制细节风险。
+ 缺点：
    + 产品的组成部分必须相同，这限制了其使用范围。
    + 如果产品的内部变化复杂，该模式会增加很多的建造者类。
+ 特点：
    + 建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。
#### 7. Proxy代理模式
#### 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
+ 优点：
    + 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。
    + 代理对象可以扩展目标对象的功能。
    + 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。
+ 缺点：
    + 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。
    + 增加了系统的复杂度。
#### 8. Adapter适配器模式
#### 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。
+ 优点：
    + 客户端通过适配器可以透明地调用目标接口。
    + 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
    + 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
+ 缺点：
    + 对类适配器来说，更换适配器的实现过程比较复杂。
#### 9. Bridge桥接模式
#### 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
+ 优点：
    + 由于抽象与实现分离，所以扩展能力强。
    + 其实现细节对客户透明。
+ 缺点：
    + 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。
#### 10. Decorator装饰模式
#### 在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
+ 优点：
    + 采用装饰模式扩展对象的功能比采用继承方式更加灵活。
    + 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。
+ 缺点：
    + 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。
#### 11. Facade外观模式
#### 是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
+ 优点：
    + 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
    + 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
    + 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。
+ 缺点：
    + 不能很好地限制客户使用子系统类。
    + 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
#### 12. Flyweight享元模式
#### 运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。
+ 优点：
    + 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
+ 缺点：
    + 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
    + 读取享元模式的外部状态会使得运行时间稍微变长。
#### 13. Composite组合模式
#### 有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
+ 优点：
    + 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。
    + 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。
+ 缺点：
    + 设计较复杂，客户端需要花更多时间理清类之间的层次关系。
    + 不容易限制容器中的构件。
    + 不容易用继承的方法来增加构件的新功能。
#### 14. Strategy策略模式
#### 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。
+ 优点：
    + 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
    + 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
    + 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
    + 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
    + 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。
+ 缺点：
    + 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
    + 策略模式造成很多的策略类。
#### 15. Observer观察者模式
#### 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。
+ 优点：
    + 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
    + 目标与观察者之间建立了一套触发机制。
+ 缺点：
    + 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
    + 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。